/*
    drive_straight.ic
    Emma Barber
    Created: 4/19/2012
    Drives robot for distance (ft, in ticks temporarily) at speed
    with delay seconds in between encoder checks.
    Modified: 4/26/2012 - Added error checking based on lecture flowchart
*/

int drive_straight(int distance, int speed, float delay) {
    //Initialize variables
    int current_ticks = 0, avg_ticks;
    int max_ticks = distance; //Will be converted later based on 10 ft encoder data.
    int right_speed = speed, left_speed = speed;
    
    //Set motors to desired speed.
    motor(LEFT_MOTOR, speed);
    motor(RIGHT_MOTOR, speed);
    
    while (current_ticks < max_ticks) {
        //Reset left and right encoders.
        LEFT_ENCODER = 0;
        RIGHT_ENCODER = 0;
        
        //Wait for motors to move.
        sleep(delay);
        
        //Correct for uneven motor speeds
        if ((LEFT_ENCODER < RIGHT_ENCODER) && (left_speed < speed)) {
            left_speed += 2;
            if (left_speed > speed)
              left_speed = speed;
            motor(LEFT_MOTOR, left_speed);
        }
        else if ((LEFT_ENCODER < RIGHT_ENCODER) && (left_speed >= speed)) {
            right_speed -= 2;
            if (right_speed > speed)
              right_speed = speed;
            motor(RIGHT_MOTOR, right_speed);
        }
        else if ((RIGHT_ENCODER < LEFT_ENCODER) && (right_speed < speed)) {
            right_speed += 2;
            if (right_speed > speed)
              right_speed = speed;
            motor(RIGHT_MOTOR, right_speed);
        }
        else if ((RIGHT_ENCODER < LEFT_ENCODER) && (right_speed < speed)) {
            left_speed -= 2;
            if (left_speed > speed)
              left_speed = speed;
            motor(LEFT_MOTOR, left_speed);
        }
        
        //Calculate how many ticks we've moved since the last check.
        avg_ticks = (LEFT_ENCODER + RIGHT_ENCODER) / 2;
        //Add result to ticks so far.
        printf("\nCurrent ticks: %d", current_ticks);
        current_ticks += avg_ticks;
    }
    
    //Turn motors off
    motor(LEFT_MOTOR, 0);
    motor(RIGHT_MOTOR, 0);
    
    return 0; //Nothing broke
}
